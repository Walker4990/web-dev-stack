<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>함수</h1>
    <script>
      // 1. 매개변수(parameter) X, 리턴값 X

      function sayHello() {
        // 함수 생성
        console.log("안녕하세요");
      } //  function 함수명(camelCase법 사용) () {}

      sayHello(); // 함수 호출

      // 2. 매개변수 O, 리턴 값 X
      function greet(name = "성모") {
        // name에 기본값을 설정하면 인자값(파라미터)을 받지 않으면 기본 값 출력
        console.log(name + "님, 안녕하세요");
      } //function 함수명(camelCase법 사용) (parameter) {}
      greet("성훈");
      greet(); // parameter를 보내지 않으면 undefined

      // 3. 매개변수 X, 리턴 값 O
      function getNumber() {
        return 1049;
      }
      getNumber(); // -> 이 자체가 1049
      console.log(getNumber());

      // 4. 매개변수 O, 리턴값 O
      function add(a, b) {
        return a + b;
      }
      console.log(add(30, 50)); // a=30, b=50
    </script>

    <h2>1. 변수의 유효범위(Scope)</h2>
    <script>
      const num1 = 100; // 어디서든 사용 : 전역 변수

      function sample1() {
        const num1 = 200; // 함수 내에서만 사용 : 지역변수
        console.log(`sample1 내부 : ${num1}`);
      }
      // 외부에 있는 변수보다 내부에 있는 변수가 우선순위가 더 높다
      console.log(`sample1 외부 : ${num1}`);
      sample1(); // function의 코드들은 정의를 내릴 뿐 출력되지 않고, 호출을 해야 출력된다.
    </script>

    <h2>2. 선언적 vs 익명 vs 화살표함수</h2>
    <script>
      // 선언적 함수(Function Declaration)
      // - 호이스팅 가능 : 코드 해석 시점에 메모리에 등록해서 선언 이전에 호출이 가능하다.
      console.log("선언적 함수 : ", multiple(3, 4));
      function multiple(a, b) {
        return a * b;
      }

      // 익명 함수(Function Expression)
      // - 함수명 존재 x, 변수에 할당함.
      const subtract = function (a, b) {
        return a - b;
      };
      console.log("익명 함수 : ", subtract(5, 8));

      // 화살표 함수(Arrow Function)
      // - function 대신 => 사용
      /*
      const divide = (a, b) => {
        return a / b;
      };*/
      const divide = (a, b) => a / b; //한줄인 경우 위의 방법과 같다
      console.log("화살표 함수 : ", divide(12, 3));
    </script>

    <h2>3. 콜백 함수</h2>
    <script>
      // 다른 함수의 인자로 전달되는 함수
      function callFunc(callback) {
        console.log("함수 호출 전");
        callback();
        console.log("함수 호출 후");
      }

      function call() {
        console.log("안녕하세요~ 콜백 함수 호출");
      }
      callFunc(call); // 괄호 없이 호출가능
    </script>

    <h2>4. 배열 관련 콜백 함수들</h2>
    <script>
      const numbers = [1, 2, 3, 4, 5];
      // 1.  값을 하나씩 출력해보기
      for (let i = 0; i < numbers.length; i++) console.log(numbers[i]);
      //forEach 함수 forEach((값, 인덱스, 배열) => {})
      numbers.forEach((value, index, array) => {
        console.log(value);
      });
      // 2. 배열의 값을 각각 2배로 만들어서 출력
      //   for (let i = 0; i < numbers.length; i++) console.log(numbers[i] * 2);
      const doubled = [];
      for (const index in numbers) {
        doubled.push(numbers[index] * 2);
        // doubled[index] = numbers[index] *2;
      }
      console.log(doubled);
      //   => map((값, 인덱스, 배열)=>{}) : 각 요소를 전부 가공하여 새로운 배열을 반환하고자 할때
      //리턴값을 받을수 있음

      const doubleMap = numbers.map((value, index, array) => {
        return value * 2;
      });
      console.log(doubleMap);
      // 3. 배열의 짝수만 출력
      //   for (let i = 1; i < numbers.length; i += 2) console.log(numbers[i]);
      for (const value of numbers) {
        if (value % 2 === 0) console.log(value);
      }
      // => filter((값, 인덱스, 배열)=>{}) : 조건에 만족하는 요소만 추출해서 새로운 배열 반환
      const evenFilter = numbers.filter((value, index, array) => {
        return value % 2 === 0; // 리턴한 값들이 true인 것만 모아서
      });
      console.log(evenFilter);

      // 4. 배열의 총 합 구하기
      let total = 0;
      for (let i = 0; i < numbers.length; i++) {
        total += numbers[i];
      }
      console.log(total);
      // => reduce((누적된 값, 현재 값, 인덱스, 배열) => {}, 초기값)
      //    : 배열의 각 요소를 누적하여 하나의 값으로 반환
      const sumReduce = numbers.reduce((acc, cur, idx, arr) => {
        console.log(`acc : ${acc}, cur : ${cur}`);
        return acc + cur;
      }, 0);
      console.log(sumReduce);
    </script>
  </body>
</html>
